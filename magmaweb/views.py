import json
from pyramid.response import Response
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPFound
from magmaweb.job import make_job_factory, JobNotFound

class Views(object):
    """Views for pyramid based web application"""
    def __init__(self, request):
        self.request = request
        self.job_factory = make_job_factory(request.registry.settings)

    def jobid(self):
        """ Returns job identifier of current request from request.matchdict['jobid']"""
        try:
            return self.request.matchdict['jobid']
        except KeyError:
            raise HTTPFound(location = self.request.route_url('home'))

    def job(self):
        """ Fetched job using jobid"""
        try:
            return self.job_factory.fromId(self.jobid())
        except JobNotFound:
            raise HTTPNotFound()

    @view_config(route_name='home', renderer='home.mak', request_method='GET')
    def home(self):
        """Returns homepage on GET. """
        return {}

    @view_config(route_name='uploaddb', renderer='uploaddb.mak')
    def uploaddb(self):
        if (self.request.method == 'POST'):
            job = self.job_factory.fromDb(self.request.POST['db_file'].file)
            return HTTPFound(location=self.request.route_url('results', jobid=job.id))
        else:
            return {}

    @view_config(route_name='results', renderer='results.mak')
    def results(self):
        """Returns results page"""
        job = self.job()
        return dict(
                    run=job.runInfo(),
                    maxmslevel=job.maxMSLevel(),
                    jobid=job.id
                    )

    @view_config(route_name='status', renderer='status.mak')
    @view_config(route_name='status.json', renderer='json')
    def job_status(self):
        """Returns status of a job"""
        jobstate = self.job_factory.state(self.jobid())
        return dict(status=jobstate, jobid=self.jobid())

    @view_config(route_name='metabolites.json', renderer='json')
    def metabolitesjson(self):
        """Returns json document with metabolites, which can be used in a extjs store

        request.params:

        start
            Offset
        limit
            Maximum nr of metabolites to return
        scanid
            Only return metabolites that have hits in scan with this identifier. Adds score column.
        filter
            Json encoded string which is generated by ExtJS component Ext.ux.grid.FiltersFeature
        sort
            How to sort metabolites. Json encoded string which is an array of objects. Eg.
                [{"property":"probability","direction":"DESC"},{"property":"metid","direction":"ASC"}]
        """
        request = self.request
        scanid = request.params['scanid'] if ('scanid' in request.params) else None
        filters = json.loads(request.params['filter']) if ('filter' in request.params) else []
        sorts = json.loads(request.params['sort']) if ('sort' in request.params) else []
        job = self.job()
        metabolites = job.metabolites(
            start=int(request.params['start']),
            limit=int(request.params['limit']),
            scanid=scanid, filters=filters, sorts=sorts
        )
        scans = job.scansWithMetabolites(filters=filters)
        return { 'total':metabolites['total'], 'rows':metabolites['rows'], 'scans':scans}

    @view_config(route_name='metabolites.csv')
    def metabolitescsv(self):
        """ Same as metabolitesjson(), but returns csv file instead of a json document """
        mets = self.metabolitesjson()
        csv = self.job().metabolites2csv(mets['rows'])
        response = Response(content_type='text/csv', body=csv.getvalue())
        # response.app_iter does not work on StringIO, so use response.body
        # response.app_iter = csv
        return response

    @view_config(route_name='chromatogram.json', renderer='json')
    def chromatogramjson(self):
        """Returns json object with the id, rt and basepeakintensity for each lvl1 scan"""
        return self.job().chromatogram()

    @view_config(route_name='mspectra.json', renderer='json')
    def mspectrajson(self):
        """Returns json object with peaks of a scan

        Also returns the cutoff applied to the scan
        and mslevel, precursor.id (parent scan id) and precursor.mz

        request.matchdict['scanid']
            Scan identifier of scan of which to return the mspectra

        request.params.mslevel
            Ms level on which the scan must be. Optional.

        """
        job = self.job()
        scanid = self.request.matchdict['scanid']
        mslevel = None
        if ('mslevel' in self.request.params):
            mslevel = self.request.params['mslevel']
        from magmaweb.job import ScanNotFound
        try:
            return job.mspectra(scanid, mslevel)
        except ScanNotFound:
            raise HTTPNotFound()

    @view_config(route_name='extractedionchromatogram.json', renderer='json')
    def extractedionchromatogram(self):
        """Returns json object with the extracted ion chromatogram for a metabolite and the id,rt of scans which have metabolite hits

        request.matchdict['metid']
            Metabolite identifier
        """
        metid = self.request.matchdict['metid']
        job = self.job()
        return {
            'chromatogram': job.extractedIonChromatogram(metid),
            'scans': job.scansWithMetabolites(metid=metid)
        }

    @view_config(route_name='fragments.json', renderer='json')
    def fragments(self):
        """Returns json object with metabolites and its lvl2 fragments when node is not set
        When node is set then returns the children fragments which have node as parent fragment

        Can be used in a Extjs.data.TreeStore.

        request.matchdict['scanid']
            Fragments on scan with this identifier

        request.matchdict['metid']
            Fragments of metabolite with this identifier

        request.params['node']
            The fragment identifier to fetch children fragments for.
        """
        job = self.job()
        request = self.request
        from magmaweb.job import FragmentNotFound
        try:
            fragments = job.fragments(
                scanid=request.matchdict['scanid'],
                metid=request.matchdict['metid'],
                node=request.params['node']
            )
            return fragments
        except FragmentNotFound:
            raise HTTPNotFound()


    @view_config(route_name='stderr.txt')
    def stderr(self):
        """ Returns file object of stderr.txt file of job"""
        response = Response(content_type='text/plain')
        response.app_iter = self.job().stderr()
        return response
