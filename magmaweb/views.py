import uuid, os, json
from pyramid.response import Response
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPFound
from sqlalchemy.sql.expression import desc, asc
from sqlalchemy.sql import exists, func
from sqlalchemy import and_
from sqlalchemy.orm.exc import NoResultFound
from sqlalchemy.orm import aliased
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from magmaweb.models import DBSession
from magmaweb.models import Metabolite, Scan, Peak, Fragment, Run, Base
from magmaweb.job import JobFactory, JobNotFound, JobQuery
"""Views for pyramid based web application"""

def fetch_job(request):
    """ Fetched job using jobid from request.session[id] or request.params[jobid]"""
    if ('jobid' in request.matchdict):
        try:
            return job_factory(request).fromId(request.matchdict['jobid'])
        except JobNotFound:
            raise HTTPNotFound()
    else:
        raise HTTPFound(location = request.route_url('home'))

def job_factory(request):
    """ Returns a job factory"""
    return JobFactory(request.registry.settings['jobrootdir'], 'results.db')

@view_config(route_name='home', renderer='home.mak')
def home(request):
    """Returns homepage on GET.
     On POST:
     1. creates job session
     2. copies file in 'db' param to job session dir
     3. redirects to results action
    """

    if (request.method == 'POST'):
        post = request.POST
        q = JobQuery()
        q.mzxml_filename=post['db'].name
        q.mzxml=post['db']
        q.mz_precision=post['mz_precision']
        q.ms_intensity_cutoff=post['ms_intensity_cutoff']
        q.msms_intensity_cutoff=post['msms_intensity_cutoff']
        q.ionisation=post['ionisation']
        q.structures=post['structures']
        q.n_reaction_steps=post['n_reaction_steps']
        q.metabolism_types=post['metabolism_types'].split(', ')
        q.max_broken_bonds=post['max_broken_bonds']
        q.abs_peak_cutoff=post['abs_peak_cutoff']
        q.rel_peak_cutoff=post['rel_peak_cutoff']
        q.precursor_mz_precision=post['precursor_mz_precision']
        q.use_msms_only=post['use_msms_only']
        q.use_fragmentation=post['use_fragmentation']

        jobid = job_factory(request).submitQuery(q)
        return Response(json.dumps({"success": True, "jobid": str(jobid) }), content_type='text/html')

    return dict()

@view_config(route_name='results', renderer='results.mak')
def results(request):
    """Returns results page"""
    job = fetch_job(request)
    return dict(run=job.runInfo(), maxmslevel=job.maxMSLevel(), jobid=job.id)

@view_config(route_name='status', renderer='status.mak')
def job_status(request):
    """Returns status of a job"""
    jobid = request.matchdict['jobid']
    jobstate = job_factory(request).state(jobid)
    return dict(status=jobstate, jobid=jobid)

@view_config(route_name='metabolites.json', renderer='json')
def metabolitesjson(request):
    """Returns json document with metabolites, which can be used in a extjs store

    request.params:

    start
        Offset
    limit
        Maximum nr of metabolites to return
    scanid
        Only return metabolites that have hits in scan with this identifier. Adds score column.
    filter
        Json encoded string which is generated by ExtJS component Ext.ux.grid.FiltersFeature
    sort
        How to sort metabolites. Json encoded string which is an array of objects. Eg.
            [{"property":"probability","direction":"DESC"},{"property":"metid","direction":"ASC"}]
    """
    scanid = request.params['scanid'] if ('scanid' in request.params) else None
    filters = json.loads(request.params['filter']) if ('filter' in request.params) else []
    sorts = json.loads(request.params['sort']) if ('sort' in request.params) else []
    job = fetch_job(request)
    metabolites = job.metabolites(
        start=int(request.params['start']),
        limit=int(request.params['limit']),
        scanid=scanid, filters=filters, sorts=sorts
    )
    scans = job.scansWithMetabolites(filters=filters)
    return { 'total':metabolites['total'], 'rows':metabolites['rows'], 'scans':scans}

@view_config(route_name='metabolites.csv')
def metabolitescsv(request):
    """ Same as metabolitesjson(), but returns csv file instead of a json document """
    mets = metabolitesjson(request)
    csv = fetch_job(request).metabolites2csv(mets['rows'])
    response = Response(content_type='text/csv', body=csv.getvalue())
    # response.app_iter does not work on StringIO, so use response.body
    # response.app_iter = csv
    return response

@view_config(route_name='chromatogram.json', renderer='json')
def chromatogramjson(request):
    """Returns json object with the id, rt and basepeakintensity for each lvl1 scan"""
    job = fetch_job(request)
    return job.chromatogram()

@view_config(route_name='mspectra.json', renderer='json')
def mspectrajson(request):
    """Returns json object with peaks of a scan

    Also returns the cutoff applied to the scan
    and mslevel, precursor.id (parent scan id) and precursor.mz

    request.matchdict['scanid']
        Scan identifier of scan of which to return the mspectra

    request.params.mslevel
        Ms level on which the scan must be. Optional.

    """
    job = fetch_job(request)
    scanid = request.matchdict['scanid']
    mslevel = None
    if ('mslevel' in request.params):
        mslevel = request.params['mslevel']
    from magmaweb.job import ScanNotFound
    try:
        mspectra = job.mspectra(scanid, mslevel)
        return mspectra
    except ScanNotFound:
        raise HTTPNotFound()

@view_config(route_name='extractedionchromatogram.json', renderer='json')
def extractedionchromatogram(request):
    """Returns json object with the extracted ion chromatogram for a metabolite and the id,rt of scans which have metabolite hits

    request.matchdict['metid']
        Metabolite identifier
    """
    metid = request.matchdict['metid']
    job = fetch_job(request)
    return {
        'chromatogram': job.extractedIonChromatogram(metid),
        'scans': job.scansWithMetabolites(metid=metid )
    }

@view_config(route_name='fragments.json', renderer='json')
def fragments(request):
    """Returns json object with metabolites and its lvl2 fragments when node is not set
    When node is set then returns the children fragments which have node as parent fragment

    Can be used in a Extjs.data.TreeStore.

    request.matchdict['scanid']
        Fragments on scan with this identifier

    request.matchdict['metid']
        Fragments of metabolite with this identifier

    request.params['node']
        The fragment identifier to fetch children fragments for.
    """
    job = fetch_job(request)
    from magmaweb.job import FragmentNotFound
    try:
        fragments = job.fragments(
            scanid=request.matchdict['scanid'],
            metid=request.matchdict['metid'],
            node=request.params['node']
        )
        return fragments
    except FragmentNotFound:
        raise HTTPNotFound()
